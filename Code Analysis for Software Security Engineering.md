# Code Analysis for Software Security Engineering
## Part 1: Code Review
### Code Review Strategy
#### Review Scope

>>> TODO: Talk about how Shane came up with checklist based on review of diagram and https://cwe.mitre.org/data/definitions/699.html

***
#### CWE Checklist
1) CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory
2) CWE-532: Insertion of Sensitive Information into Log File
3) CWE-200: Exposure of Sensitive Information to an Unauthorized Actor
4) CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
5) CWE-73: External Control of File Name or Path
6) CWE-126: Buffer Over-read
7) CWE-127: Buffer Under-read
8) CWE-125: Out-of-bounds Read
9) CWE-124: Buffer Underwrite ('Buffer Underflow')
10) CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data

>>>TODO: Shane add more details here 

***

#### Automated Tool Selection
1) SonarCloud
2) CodeQL
3) Fortify
4) Flaw Finder
   
Our team decided to use a handful of automated code analysis tools to get a chance to utilize a diverse set of tools while providing a comprehensive report of these findings. The ability to run more than one automated code analysis tool allows us to see what other tools are also finding to see if there is any noise or really hone in on particular areas of focus. The flip side of this is that we could also run into more noise that needs to be sifted through to better see if it's a true vulnerability or issue for our system. The above are the tools we utilized and the results of our findings can be found below.
   
#### What challenges did you expect before starting the code review?

>>> TODO:
>>> - Not familiar with C/Rust code

#### How did your code review strategy attempt to address the anticipated challenges?

>>> TODO: 

***
### Manual Code Review Findings

>>> TODO: 

***

### Automated Code Scan Findings
#### Automated #1 [SonarCloud](https://sonarcloud.io/)

One of the automated tools that has been used to scan the Suricata codebase has been SonarCloud. This particular automated code scanning tool was leveraged due to its availability for use with both public and open-source repositories from GitHub and other sources without need a of a subscription, easy integration into GitHub's code scanning functionality, and it's compatability with a variety of coding languages. The Suricata open-source software project includes multiple languages with its majority having been written in the C programming language and other significant shares being written in Rust, Python, and more. This versatility from the tool allowed for the spotting of issues from not just one specific code region or language comprising Suricata but the whole application. Upon review of the analysis results, it was found that many of the issues raised for the Suricata codebase pertained to issues of reliability and maintainability with 84 and 7,651 issues for the two categories respectively. For issues relating to security, which is the primary area of interest of the application for this course, there were a much more managable 24 issues raised. A link to the overall analysis report generated by SonarCloud is provided below. It is the security issues highlighted in the report which will be the primary talking point of the tool's findings.

[SonarCloud Analysis Output Link](https://sonarcloud.io/summary/overall?id=shellis0_suricata)

![image](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/SonarCloud%20Scan%20Reults%20Image.png)

As can be seen in an image listing the security issues provided from the SonarCloud analysis above, the 24 issues aligned with two distinct concerns with the first concern being found twice and the second concern being found in multiple instances of the codebase. Both of the topics of concern found within the security issues of the tool aligned with CWEs, both of which were not concerns identified within our initial CWE checklist.

The first concern discussing TOCTOU vulnerabilities aligned with CWE-367 and was found both times within a singular file, `src/conf-yaml-loader.c`. The general details of the CWE involve the software security weakness associated with the actions of checking and utilizing code and the periods of time between those events allowing for potential exploits to occur. This finding, more specifically the file for which the CWE was linked, was found to be a key area of focus for the code analysis as the weakness mentioned impacted the file responsible for loading and parsing the YAML configuration file used by Suricata. From previous project deliverables concerning use cases and misuse cases, assurance cases, and threat modeling the configuration component of Suricata, through its YAML file, was a recurring area of great importance as it is in charge of the setup and management of Suricata.

The second concern was identified across 22 security issues listed in the automated analysis spanning 22 separate C source code files. Each of the source files listed with the issues pertaining to this concern were files responsible for various alerts, logs, outputs, and utilities. This concern aligned with CWE-14 which is a weakness involving memory handling where the compiler chooses to optimize by not accessing memory rather than clearing it as specified by source code implementations. This weakness was also found to be important as another major component to Suricata's operation is its capactity to output information relating to information flowing across the network it is responsible for analyzing. It is able to do this, as has been learned through previous deliverables, in a variety of ways the most notable which being alerting and logging mechanisms for reporting on network activity. CWEs being listed in relation to these areas of code could be of importance as they too are a parts of prominant feature from the software.

Below is a table comprising the CWEs accquired from the SonarCloud tool alongside relevant information and affected files for further viewing. More detailed coverage of the respective CWEs from this tool beyond initial findings will be evaluated further within part two of the deliverable below. 

| **Security Issue** | **Severity** | **CWE Entry** | **Affected Files** |
| :--------------------------------------------------------- | :--: | :------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------- |
| Acessing files should not introduce TOCTOU vulnerabilities | High | [CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition](https://cwe.mitre.org/data/definitions/367) | [src/conf-yaml-loader.c](https://github.com/OISF/suricata/blob/master/src/conf-yaml-loader.c) |
| "memset" should not be used to delete sensitive data       | High | [CWE-14: Compiler Removal of Code to Clear Buffers](https://cwe.mitre.org/data/definitions/14.html)      | Some examples include: [src/alert-debuglog.c](https://github.com/OISF/suricata/blob/master/src/alert-debuglog.c), [src/log-tcp-data.c](https://github.com/OISF/suricata/blob/master/src/log-tcp-data.c), [src/output-json-file.c](https://github.com/OISF/suricata/blob/master/src/output-json-file.c), [src/util-logopenfile.c](https://github.com/OISF/suricata/blob/master/src/util-logopenfile.c) |

***

#### Automated #2 [GITHUB CodeQL](https://github.com/nsteck17/suricata/security/code-scanning)
Incase access to the Fork and scan results are limited, here's a PDF of the pages: 
- [Forked Suricata CodeQL PDF Page 1 of 2](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/CodeQL/Code%20scanning%20alerts%20%C2%B7%20nsteck17_suricata%20-%20P1.pdf)
- [Forked Suricata CodeQL PDF Page 2 of 2](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/CodeQL/Code%20scanning%20alerts%20%C2%B7%20nsteck17_suricata%20-%20P2.pdf)

![image](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/CodeQL/Screenshot%202024-12-07%20093638.png)

When creating the fork of Suricata, at first we struggled to get it working with CodeQL. We learned this is because the C code's build commands were not valid for the default CodeQL generated approach. After some trial and error (and educated review how CodeQL is setup/works) we finally saw that it is basaed on the .github/workflows/codeql.yml configuration and actually Suricata's source code actually already had an "advanced" setup [here](https://github.com/OISF/suricata/tree/master/.github/workflows) and finally we were able to get some results. 

Our initial checklist of CWEs identified CWE-22 and CWE-73 that was found in by results of the CodeQL scans, confirming our original thoughts. 
These both were associated to instances of "Uncontrolled data used in path expression" findings which there were three seperate entries for in the results set. 
![image](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/CodeQL/Screenshot%202024-12-07%20100156.png)
  
***

#### Automated #3 [Fortify Scan](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/UP%20Fortify%20Scan/suricata-version-Fortify_Security_Report.pdf)
![image](https://github.com/user-attachments/assets/052d0c3a-76dc-404b-b345-d74d219df8c1)

Nathan setup the Fortify scan using his work's (Union Pacific Railroad) provided Fortify utility scanning setup and default rules there (not on a GitHub intergration). He thought this would be a good "industry standard" approach as this is the same scan the rest of the code that runs in production goes through. Interestingly enough though it didn't actually scan all the C and Rust language files. It specifically captured the Python and other utility files (like Docker) where credentials are stored. So the results were not fully "inclusive" but it did give an interesting unique insight others may not be able to do.

Linked are a PDF of results, but it's important to note the scan also produced an "FPR" file that could be opened by Fortify workbench software. This makes it easeir to review the scan results in a more "user friendly" way with more details. This includes full code references and additional details not seen in the PDF output. 

#### Automated #4 [Flaw Finder](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/flawfinder_results.txt)
Flawfinder is a static analysis tool specifically designed for C and C++ programs. This language is used in our open-source projects Suricata. Writting in this language is prone to common security vulnerabilities such as buffer overflows, format string vulnerabilities, and unsafe memory operations. Flawfinder is a suitable choice because:

- **Targeted for C/C++:** It has a comprehensive database of over 200 rules targeting common pitfalls in C/C++ codebases.
- **Quick Analysis**: It provides rapid analysis of large codebases, identifying vulnerabilities with minimal setup.
- **Free and Open-Source:** As an open-source tool, Flawfinder aligns well with the ethos of analyzing other open-source projects like Suricata.
- **Granular Reporting:** It categorizes findings by risk levels, allowing teams to prioritize remediation efforts effectively.
- 
**How Flawfinder Works**
Flawfinder operates by:
- **Parsing Source Code**: It examines the source files line by line to identify potentially dangerous functions and constructs.
- **Matching Patterns**: It matches code patterns against a database of known vulnerable functions (e.g., printf, system, random).
- **Assigning Risk Levels**: Each finding is assigned a risk level from 0 (low) to 5 (high), helping developers prioritize their attention.
- **Providing Recommendations**: The tool offers practical suggestions for mitigating the identified vulnerabilities.
- **Performance Metrics**: Flawfinder also provides performance statistics, such as lines of code analyzed per second, and summarizes the overall risk.

**Results**
Before running Flawfinder, the first step was to obtain a local copy of the Suricata source code. This was achieved by cloning the project's Git repository, which provides access to the full codebase.
![image](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/Screenshot%202024-12-08%20143309.png)

- **Format String Vulnerabilities (CWE-134)**

printf in /plugins/napatech/util-napatech.h:86 and ./src/suricata-common.h:408

snprintf in ./src/util-print.h:28

syslog in ./src/win32-syslog.h:78

Severity Level: 4

**Impact**: If format strings can be influenced by an attacker, they may exploit these functions to execute arbitrary code or read sensitive memory.

- **Command Execution Vulnerabilities (CWE-78)**
  
system in ./src/suricata.h:144 and ./src/util-reference-config.h:37

Severity Level: 4

**Impact:** The system function executes shell commands, making it vulnerable to injection attacks if input is not properly sanitized.

- **Weak Random Number Generation (CWE-327)**
  
Instance: random in ./src/app-layer-ssl.h:254

Severity Level: 3

**Impact**: The random() function is predictable and unsuitable for cryptographic purposes, such as generating keys or nonces.
***

***
## Part 2: Key Findings and Contributions
### Summary of Findings
>>> TODO:
We found common CWEs we expected to find in our checklist in our automated review:
1) CWE-134
#### Description
CWE-134 refers to a class of vulnerabilities that arise when user-controlled input is used as a format string in functions such as **printf, snprintf, fprintf, or syslog** without proper validation. This vulnerability can allow attackers to execute arbitrary code, crash the application, or gain access to sensitive information.

#### Found in files
- **Format String Vulnerabilities (CWE-134)**

printf in /plugins/napatech/util-napatech.h:86 and ./src/suricata-common.h:408

snprintf in ./src/util-print.h:28

syslog in ./src/win32-syslog.h:78

Severity Level: 4

**Impact**: If format strings can be influenced by an attacker, they may exploit these functions to execute arbitrary code or read sensitive memory.

#### Analysis
Flawfinder scans the source files in the repository for .c and.h files and breaks down the code into tokens and syntax elements for analysis. In this case, it scanned files like:

- /plugins/napatech/util-napatech.h
- ./src/suricata-common.h
- ./src/util-print.h
- ./src/win32-syslog.h

<img width="302" alt="image" src="https://github.com/user-attachments/assets/d8557f09-58c7-466d-a012-89a9e375b25d">


#### Summary

It seems like Flawfinder analysis of the Suricata codebase identified multiple instances of CWE-134. These vulnerabilities occur when user-controlled input is used as a format string, potentially allowing attackers to execute arbitrary code, crash the application, or expose sensitive information. This is an interesting finding as other automated tools may have found this as a vulnerability but not as an emphasis.
***

2) CWE-22
>>> TODO: Matt
>>> Description,
>>> Found in files list/link,
>>> Analysis (Manual/Automated),
>>> Summary

***

3) [CWE-73](https://cwe.mitre.org/data/definitions/73.html) **External Control of File Name or Path**
#### Description
The product allows user input to control or influence paths or file names that are used in filesystem operations. 
#### Found in files list/link,
#### Analysis (Manual/Automated),
#### Summary

***

4) CWE-95
#### Description
CWE-95 is defined as "Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')". The code receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. "eval"). This may allow an attacker to execute arbitrary code, or at least modify what code can be executed.

#### Found in files
[LINE 259 of suricatasc.py](https://github.com/OISF/suricata/blob/master/python/suricata/sc/suricatasc.py#L259)
![image](https://github.com/user-attachments/assets/3510aa98-ecd7-4c16-a946-af609c372571)

#### Analysis
The Fortify Scan produced an FPR file with results that could be opened with it's Fortify Workbench Tool (and a summary PDF of results). We took a screenshot of the workbench utility reporting these results.
![image](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/UP%20Fortify%20Scan/1-critical-cwe95-cwe494-cwe094.PNG)

#### Summary
The automated fortify scan found this "Critical" issue of accepting user input. However I believe it is a false positive based on my review. Specifically the Fortify valunerability and CWE is indicating that user input is not sanitized before being executed. However, once you review the rest of the code starting with the function's name you see that it's interactive user input and more specitically the user is selecting from the list of options of commands. If the user is not allowed to enter anything like they, the vulnerability doesn't actually exist. 
![image](https://github.com/user-attachments/assets/db21cf22-8fea-4b59-b99d-34c0963fd4b5)

This is command-line interafaces so they're not able to "hack" the UI to enter invalid inputs another way. They only are given a set of options. 
![image](https://github.com/user-attachments/assets/a17c3f9c-a2d0-4fb3-8c42-2a23e963f0ea)

So based on my findings this is actually a false positive. I picked this example due to it being reported as critical, easily visiblity manually reviewed and actually a false positive. From expierence, this is a very REAL situation in industry. I (Nathan) work at Union Pacific Railroad and we use automated Fortify Scan results in our CI/CD pipeline for deployments to prevent code from going to prod if they have a critical vulnerability like this. So this could would not be "deployable" to production based on this without an exception. As well, when we delivered code to a client (the Norfolk Southern Railroad) we had to provide these Fortify scan results to prove none were in the deliverable executable code we provided. I find these scenarios a very good example of how automation isn't perfect. 

***

5) [CWE-367](https://cwe.mitre.org/data/definitions/367): Time-of-check Time-of-use (TOCTOU) Race Condition
#### Description
As was briefly mentioned in the automated code scan findings pertaining to SonarCloud, CWE-367 identifies the weakness "Time-of-check Time-of-use (TOCTOU) Race Condition". This weakness involves both software states and timing where a malicious actor may try to gain access to the affected software, in this case the configuration file of Suricata, in order to conduct some unsavory actions within the system. The malicious action outlined in this weakness would happen in the time that has elapsed between the moment a piece of software has had its state verified for its integrity and the time when the software is put to use. This finding has relevancy to Suricata as the weakness has been found to be most impactful in software like Suricata that has an emphasis on "files, memory, or even variables in multithreaded programs". 

#### Affected files
The file in which the CWE was raised from the automated scan was in src/conf-yaml-loader.c on [line 500](https://github.com/OISF/suricata/blob/master/src/conf-yaml-loader.c#L500) and [line 578](https://github.com/OISF/suricata/blob/master/src/conf-yaml-loader.c#L578).

**Line 500** \
![image](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/Suricata%20CWE-367%20Image%201.png)

**Line 578** \
![image](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/Suricata%20CWE-367%20Image%202.png)

#### Analysis
Based on the images provided for the associated file, the two security issues raised for this CWE pertain to a specific implementation seen within the file for parsing the YAML configuration. In particular, the code snippet under scrutiny is in regard to how the file is being opened using `fopen()` for reading purposes on two separate lines. The code fragment identified is `infile = fopen(filename, "r")` where `infile` is a file pointer (denoted as `FILE*`), `filename` is a character pointer (denoted as `char*`), and `"r"` is a character pointer passed into the function specified to serve as the mode in which the file will be opened which is for reading in this case.

The problem derived from the two images below provided from the SonarCloud analysis relate to the order of operations used for handling the configuration file reads within the parsing source file for loading the YAML file with and without prefixes. Both instances show the checking being conducted for each respective file open taking place prior to attempting to open the file for reading which alludes to the TOCTOU vulnerabilitiy potential occurring between the file verification and open steps within the code at each location. The official documentation page for CWE-367 outlines a variety of possible mitigations to consider for this particular issue. While SonarCloud provides an example of code that would mitigate the weakness, the example listed applies to the action of opening a file for writing by adding an additional check for whether the file exists beforehand through the use of the `"wx"` mode. This example would not be directly translatable to instances of reading from a file however as there is no equivalent mode available for opening a file for reading according to [documentation](https://cplusplus.com/reference/cstdio/fopen/) on `fopen()` as the file must exist in order to be read from in the first place.

Other potential mitigations that could be considered for these cases could include rearranging the order of the two operations such that the `fopen()` function would precede the file verification using `stat()`, implmenting an additional verification check after opening the file, implementing an additional design measure to monitor file accessors, or to limit access times of the file to reduce the potential window of access between the initial verification check and file open by a malicious actor. Both of the analysis images show comments denoting the TOCTOU vulnerability in relation to another analysis tool by the name of [Coverity](https://scan.coverity.com/), so it appears that the developers of Suricata are aware of this possible weakness for both instances but we are not certain of their intentions for this code as of this time.

**File Check Prior to Line 500** \
![image](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/Suricata%20CWE-367%20Results%20Image%201.png)

**File Check Prior to Line 578** \
![iamge](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Code%20Analysis%20Brainstorm/Suricata%20CWE-367%20Results%20Image%202.png)

#### Summary
This CWE was one of two CWEs provided by the automated code scan conducted using SonarCloud. This particular CWE was found to be a standout aside from other CWEs attained from our initial CWE checklist as well as CWEs obtained from other automated tools. We felt it should receive a more detailed manual review due to the potential impact it could have on the configuration file of Suricata as that is a highly important component of the software. The Suricata YAML file has been highlighted in previous deliverables, most notably our [threat modeling deliverable](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Designing%20for%20Software%20Security%20Engineering.md), as a key area of focus as it is the commanding file for how Suricata is to act and report information. Thinking to our perceived hospital environment, the consequences resulting from a TOCTOU vulnerability could lead to serious security concerns as a malicous actor could directly interfere with how Suricata is configured to run within a hospital system causing slow downs or crashes limiting the effectiveness of tool and lower the protections it provides through network analysis. The reduced protection resulting from the afformentioned action could enable the malicious actor to interfere with medical devices or inject malicous code into Suricata as has been discussed in our [third](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Requirements%20for%20Software%20Security%20Engineering.md#usemisuse-case-3-intrusion-preventing-system) and [fifth](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Requirements%20for%20Software%20Security%20Engineering.md#usemisuse-case-5-rule-configuration-management) misuse cases within our [SSE requirements deliverable](https://github.com/UNO-CYBR-8420-Team1/CYBR8420-Suricata/blob/main/Requirements%20for%20Software%20Security%20Engineering.md).

***

6) [CWE-14](https://cwe.mitre.org/data/definitions/14.html): Compiler Removal of Code to Clear Buffers
>>> TODO: Shane 
#### Description

#### Affected Files

| File Name                 | Line Number                                                                        |
| :------------------------ | :--------------------------------------------------------------------------------: |
| src/alert-debuglog.c      | [411](https://github.com/OISF/suricata/blob/master/src/alert-debuglog.c#L411)      |
| src/alert-fastlog.c       | [215](https://github.com/OISF/suricata/blob/master/src/alert-fastlog.c#L215)       |
| src/log-httplog.c         | [538](https://github.com/OISF/suricata/blob/master/src/log-httplog.c#L538)         |
| src/log-stats.c           | [200](https://github.com/OISF/suricata/blob/master/src/log-stats.c#L200)           |
| src/log-tcp-data.c        | [201](https://github.com/OISF/suricata/blob/master/src/log-tcp-data.c#L201)        |
| src/log-tlslog.c          | [160](https://github.com/OISF/suricata/blob/master/src/log-tlslog.c#L160)          |
| src/log-tlsstore.c        | [379](https://github.com/OISF/suricata/blob/master/src/log-tlsstore.c#L379)        |
| src/output-eve-stream.c   | [106](https://github.com/OISF/suricata/blob/master/src/output-eve-stream.c#L106)   |
| src/output-filestore.c    | [297](https://github.com/OISF/suricata/blob/master/src/output-filestore.c#L297)    |
| src/output-json-alert.c   | [876](https://github.com/OISF/suricata/blob/master/src/output-json-alert.c#L876)   |
| src/output-json-anomaly.c | [327](https://github.com/OISF/suricata/blob/master/src/output-json-anomaly.c#L327) |
| src/output-json-dns.c     | [478](https://github.com/OISF/suricata/blob/master/src/output-json-dns.c#L478)     |
| src/output-json-drop.c    | [237](https://github.com/OISF/suricata/blob/master/src/output-json-drop.c#L237)    |
| src/output-json-file.c    | [282](https://github.com/OISF/suricata/blob/master/src/output-json-file.c#L282)    |
| src/output-json-frame.c   | [484](https://github.com/OISF/suricata/blob/master/src/output-json-frame.c#L484)   |
| src/output-json-http.c    | [645](https://github.com/OISF/suricata/blob/master/src/output-json-http.c#L645)    |
| src/output-json-smtp.c    | [186](https://github.com/OISF/suricata/blob/master/src/output-json-smtp.c#L186)    |
| src/output-json-stats.c   | [411](https://github.com/OISF/suricata/blob/master/src/output-json-stats.c#L411)   |
| src/output-json-tls.c     | [547](https://github.com/OISF/suricata/blob/master/src/output-json-tls.c#L547)     |
| src/output-lua.c          | [882](https://github.com/OISF/suricata/blob/master/src/output-lua.c#L882)          |
| src/stream-tcp.c          | [6042](https://github.com/OISF/suricata/blob/master/src/stream-tcp.c#L6042)        |
| src/util-logopenfile.c    | [927](https://github.com/OISF/suricata/blob/master/src/util-logopenfile.c#L927)    |

#### Analysis (Manual/Automated)

#### Summary

***
>>> TODO: Overall notes? maybe not?

### Ongoing Contributions
Team 1’s planned or ongoing contributions to the upstream OSS consist of keeping an eye on further developments of Suricata. There seems to be areas where the OSS can be improved such as a login function, integration with more SIEM like functions within the software if Suricata has aspirations of taking on such ideas to better sift through the data that it collects and permission based roles. As for code changes, our group is not as well versed on C and Rust code so the upkeep and contribution wouldn’t be much on the code change help. However, following up with recent implementations, updates, and understanding the news letters that are released help us stay more up to date and what to expect when reviewing OSS systems in an open source community. Suricata had a recent release and implementation as of October 1, 2024 and the community continues to support and fix vulnerabilities. As a group we would like to periodically stay on top with trends that we work with in our own environments and see possibly how they could contribute to other OSS systems.

### [GITHUB Project Board Link](https://github.com/orgs/UNO-CYBR-8420-Team1/projects/1/views/2)
### Individual Contributions
- Ben
  - TODO
- Grace
  - TODO
- Shane
  - TODO
- Matt
  - TODO
- Nathan
  - I started off by immediately attempting to fork the Suricata OOS GitHub codebase and get a quick setup of whatever running I could. However, I wasn't successful and didn't get back to it until after thankgiving when I could touchbase with Shane and Ben on 12/01/2024. Ben was attempting to get CodeQL running as well, so we prevent further duplication of efforts and I was able to get CodeQL setup working the next day and updated the team. I also leveraged my work's Fortify scanning installation at Union Pacific to attempt to scan the sourcecode however the tools were not configured for the C/Rust programming language and we got minimal results (we primarly focuses on Java and Javascript). In the group meeting I participated in our group discussion and the pressed to keep us organized and actionable by dividing up the assignments of individual deep dive of specific CWEs we found in our scan results so we can all make steps forward on individual contribution. I chose CWE-95 to do a deep dive on (with an example) based on my initial review of Fortify results and the related code. I am familiar with C++ from undergrad school years ago, but the C/Rust code took a bit to understand how to read. I also tried to put together the structure of the deliverables and first set of details for the team to try to build off of based on our team's initial agreement of how to layout details (adding notes to the reflection and other sections of this submission). 
    
***
### Team Reflection
This milestone proved to have some challenges in terms of working around holidays to meet with team members but we were able to overcome this by working through chat, Friday meetups, and discord calls. We were able to start out with an initial manual code analysis to get CWEs that may align with our OSS. We found that after doing a manual analysis and then pairing that with automatic analysis there were commonalities to help reinforce that this would be a great place to hone in on our CWEs. Our group chose to use several different automatic code analysis tools which ultimately worked in our favor to see what matched and if we were on the right track. The idea that we had some similar CWEs on different code tools didn’t necessarily mean those were all concrete and fit to our system but allowed us to take a closer look at the results that ultimately had ones that were true to our OSS. One of the tougher parts was combing through all of this data and making sure it was relevant to our system. In some cases it felt like there was a lot of noise being presented to us, however after utilizing multiple code analysis scans we could narrow the results down to our system needs. Additionally our group did a great job in our group discussion working around tasks and making clear expectations which allowed us to work cohesively for this section of milestone.
